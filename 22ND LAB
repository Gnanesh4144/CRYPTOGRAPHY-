#include <stdio.h>
#include <stdint.h>
uint8_t IP[] = {1, 5, 2, 0, 3, 7, 4, 6};
uint8_t IP_INV[] = {3, 0, 2, 4, 6, 1, 7, 5};
uint8_t EP[] = {3, 0, 1, 2, 1, 2, 3, 0};
uint8_t P4[] = {1, 3, 2, 0};
uint8_t P10[] = {2, 4, 1, 6, 3, 9, 0, 8, 7, 5};
uint8_t P8[] = {5, 2, 6, 3, 7, 4, 9, 8};
uint8_t S0[4][4] = {
    {1, 0, 3, 2},
    {3, 2, 1, 0},
    {0, 2, 1, 3},
    {3, 1, 3, 2}
};
uint8_t S1[4][4] = {
    {0, 1, 2, 3},
    {2, 0, 1, 3},
    {3, 0, 1, 0},
    {2, 1, 0, 3}
};
uint8_t permute(uint8_t in, uint8_t* p, int n) {
    uint8_t out = 0;
    for (int i = 0; i < n; i++) {
        out <<= 1;
        out |= (in >> (7 - p[i])) & 1;
    }
    return out;
}
uint8_t leftShift5(uint8_t in, int shifts) {
    return ((in << shifts) | (in >> (5 - shifts))) & 0x1F;
}
uint16_t keyGen(uint16_t key, uint8_t* k1, uint8_t* k2) {
    uint16_t perm = 0;
    for (int i = 0; i < 10; i++) {
        perm <<= 1;
        perm |= (key >> (9 - P10[i])) & 1;
    }
    uint8_t left = (perm >> 5) & 0x1F;
    uint8_t right = perm & 0x1F;
    left = leftShift5(left, 1);
    right = leftShift5(right, 1);
    uint16_t merged = (left << 5) | right;
    *k1 = 0;
    for (int i = 0; i < 8; i++) {
        *k1 <<= 1;
        *k1 |= (merged >> (9 - P8[i])) & 1;
    }
    left = leftShift5(left, 2);
    right = leftShift5(right, 2);
    merged = (left << 5) | right;
    *k2 = 0;
    for (int i = 0; i < 8; i++) {
        *k2 <<= 1;
        *k2 |= (merged >> (9 - P8[i])) & 1;
    }
    return 0;
}
uint8_t sbox(uint8_t in, uint8_t box[4][4]) {
    uint8_t row = ((in & 0x8) >> 2) | (in & 0x1);
    uint8_t col = (in >> 1) & 0x3;
    return box[row][col];
}
uint8_t f(uint8_t r, uint8_t sk) {
    uint8_t ep = 0;
    for (int i = 0; i < 8; i++) {
        ep <<= 1;
        ep |= (r >> (3 - EP[i])) & 1;
    }
    uint8_t x = ep ^ sk;
    uint8_t left = (x >> 4) & 0xF;
    uint8_t right = x & 0xF;
    uint8_t out = (sbox(left, S0) << 2) | sbox(right, S1);
    uint8_t p4out = 0;
    for (int i = 0; i < 4; i++) {
        p4out <<= 1;
        p4out |= (out >> (3 - P4[i])) & 1;
    }
    return p4out;
}
uint8_t fk(uint8_t in, uint8_t k1, uint8_t k2, int isDecrypt) {
    uint8_t ip = permute(in, IP, 8);
    uint8_t left = ip >> 4;
    uint8_t right = ip & 0xF;
    uint8_t t1 = f(right, isDecrypt ? k2 : k1);
    left ^= t1;
    uint8_t swapped = (right << 4) | left;
    right = swapped & 0xF;
    left = swapped >> 4;
    uint8_t t2 = f(right, isDecrypt ? k1 : k2);
    left ^= t2;
    uint8_t preout = (left << 4) | right;
    uint8_t out = permute(preout, IP_INV, 8);
    return out;
}
void encryptCBC(uint8_t* pt, uint8_t* ct, int n, uint8_t k1, uint8_t k2, uint8_t iv) {
    uint8_t prev = iv;
    for (int i = 0; i < n; i++) {
        uint8_t block = pt[i] ^ prev;
        ct[i] = fk(block, k1, k2, 0);
        prev = ct[i];
    }
}
void decryptCBC(uint8_t* ct, uint8_t* pt, int n, uint8_t k1, uint8_t k2, uint8_t iv) {
    uint8_t prev = iv;
    for (int i = 0; i < n; i++) {
        uint8_t temp = fk(ct[i], k1, k2, 1);
        pt[i] = temp ^ prev;
        prev = ct[i];
    }
}
int main() {
    uint8_t plaintext[2] = {0x01, 0x23};
    uint8_t ciphertext[2], decrypted[2];
    uint8_t iv = 0xAA;
    uint8_t k1, k2;
    uint16_t key = 0x1FD;
    keyGen(key, &k1, &k2);
    encryptCBC(plaintext, ciphertext, 2, k1, k2, iv);
    printf("Encrypted: %02X %02X\n", ciphertext[0], ciphertext[1]);
    decryptCBC(ciphertext, decrypted, 2, k1, k2, iv);
    printf("Decrypted: %02X %02X\n", decrypted[0], decrypted[1]);
    return 0;
}
