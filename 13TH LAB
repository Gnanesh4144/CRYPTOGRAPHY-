#include <stdio.h>
#define MOD 26
int modInverse(int a) {
    a %= MOD;
    for (int x = 1; x < MOD; x++)
        if ((a * x) % MOD == 1)
            return x;
    return -1;
}
int inverseMatrix(int in[2][2], int out[2][2]) {
    int det = (in[0][0]*in[1][1] - in[0][1]*in[1][0]) % MOD;
    if (det < 0) det += MOD;
    int invDet = modInverse(det);
    if (invDet == -1) return 0; 
    out[0][0] =  (in[1][1] * invDet) % MOD;
    out[0][1] = (-in[0][1] * invDet) % MOD;
    out[1][0] = (-in[1][0] * invDet) % MOD;
    out[1][1] =  (in[0][0] * invDet) % MOD;
    for (int i = 0; i < 2; i++)
        for (int j = 0; j < 2; j++)
            if (out[i][j] < 0) out[i][j] += MOD;
    return 1;
}
void multiplyMatrix(int a[2][2], int b[2][2], int result[2][2]) {
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 2; j++) {
            result[i][j] = 0;
            for (int k = 0; k < 2; k++)
                result[i][j] += a[i][k] * b[k][j];
            result[i][j] %= MOD;
        }
    }
}
int toNum(char c) {
    return c - 'A';
}
void printMatrix(int mat[2][2]) {
    for (int i = 0; i < 2; i++)
        printf("[ %2d %2d ]\n", mat[i][0], mat[i][1]);
}
int main() {
    int plaintext[2][2] = {
        {toNum('H'), toNum('L')},
        {toNum('E'), toNum('L')}
    };
    int ciphertext[2][2] = {
        {toNum('Z'), toNum('S')},
        {toNum('K'), toNum('U')}
    };
    int inverseP[2][2], key[2][2];
    printf("Plaintext Matrix (P):\n");
    printMatrix(plaintext);
    printf("\nCiphertext Matrix (C):\n");
    printMatrix(ciphertext);
    if (!inverseMatrix(plaintext, inverseP)) {
        printf("\nError: Plaintext matrix is not invertible mod 26.\n");
        return 1;
    }
    printf("\nInverse of Plaintext Matrix (P^-1):\n");
    printMatrix(inverseP);
    multiplyMatrix(ciphertext, inverseP, key);
    printf("\nRecovered Key Matrix (K = C * P^-1 mod 26):\n");
    printMatrix(key);
    return 0;
}
